########################################################################
# 98_ApacheStatus.pm
# 
# ApacheStatus queries a server-statuspage generated by Apaches 
# mod_status and generates various readings from it. The query is 
# repeated in a given interval. 
#
# 2017 by Thomas Nesges <thomas@nesges.eu>
########################################################################

package main;

use strict;
use warnings;
use HttpUtils;
use HTML::TreeBuilder::XPath;

sub ApacheStatus_Initialize($);
sub ApacheStatus_Define($$);
sub ApacheStatus_Undef($$);
sub ApacheStatus_Set($@);
sub ApacheStatus_Get($@);
sub ApacheStatus_Attr(@);
sub ApacheStatus_Read($$$);
sub ApacheStatus_SetTimer($;$);
sub ApacheStatus_Reset($);
sub ApacheStatus_FetchStatus($);

my %ApacheStatus_sets = (
	"allreadings"	    => "yes,no",
	"disable"	        => "",
	"enable"	        => "",
	"reset"	            => "",
	"refresh"	        => ""
);

sub ApacheStatus_Initialize($) {
    my ($hash) = @_;

    $hash->{DefFn}      = 'ApacheStatus_Define';
    $hash->{UndefFn}    = 'ApacheStatus_Undef';
    $hash->{SetFn}      = 'ApacheStatus_Set';
    $hash->{GetFn}      = 'ApacheStatus_Get';
    $hash->{AttrFn}     = 'ApacheStatus_Attr';
    $hash->{ReadFn}     = 'ApacheStatus_Read';

    $hash->{AttrList} =
        "readingsChilds:yes,no readingsChildColumnDesc:yes,no readingsClients:yes,no readingsSSL:yes,no readingsServer:yes,no readingsScoreboard:yes,no"
        . " keepBuf:yes,no keepOldReadings:yes,no disabled:yes,no autoReset:yes,no"
        . " readingsChildsRowFilter readingsChildsColumnFilter"
        . " localnetwork"
        . " disabledForIntervals timeout httpVersion"
        . " ".$readingFnAttributes;
}

sub ApacheStatus_Define($$) {
    my ($hash, $def) = @_;
    my @param = split('[ \t]+', $def);
    
    if(int(@param) < 3) {
        return "too few parameters: define <name> ApacheStatus <url> [interval]";
    }
    
    my $name = $param[0];
    
    $hash->{NAME}       = $name;
    $hash->{url}        = $param[2];
    $hash->{interval}   = $param[3] || 300;
    $hash->{STATE}      = 'defined';
    $hash->{VERSION}    = '0.2';

    # set default settings on first define
    if( $init_done && !defined($hash->{OLDDEF}) ) {
        $attr{$name}{autoReset}                 = 'yes';
        $attr{$name}{disabled}                  = 'no';
        $attr{$name}{'event-on-change-reading'} = '.*';
        $attr{$name}{keepBuf}                   = 'no';
        $attr{$name}{keepOldReadings}           = 'no';
        $attr{$name}{readingsChilds}            = 'no';
        $attr{$name}{readingsChildColumnDesc}   = 'no';
        $attr{$name}{readingsChildsRowFilter}   = '!request:^OPTIONS !request:^NULL';
        $attr{$name}{readingsChildsColumnFilter}= 'req conn child client request';
        $attr{$name}{readingsClients}           = 'no';
        $attr{$name}{readingsScoreboard}        = 'no';
        $attr{$name}{readingsServer}            = 'no';
        $attr{$name}{readingsSSL}               = 'no';
    }
    
    ApacheStatus_SetTimer($hash, 2);
    return undef;
}

sub ApacheStatus_Undef($$) {
    my ($hash, $arg) = @_; 
    # nothing to do
    return undef;
}

sub ApacheStatus_Get($@) {
	my ($hash, @param) = @_;
	# nothing to do
	return undef;
}

sub ApacheStatus_Set($@) {
	my ($hash, @param) = @_;
	
	return '"set ApacheStatus" needs at least one argument' if (int(@param) < 2);
	
	my $name = shift @param;
	my $opt = shift @param;
	my $value = join("", @param);
	
	if(!defined($ApacheStatus_sets{$opt})) {
		my $commandstring='';
		foreach my $command (keys %ApacheStatus_sets) {
		    my $args = $ApacheStatus_sets{$command};
		    $commandstring .= $command;
		    $commandstring .= ':'.($args?$args:'noArg');
		    $commandstring .= ' ';
		}
		return "Unknown argument $opt choose one of $commandstring";
	}
	
	Log3 $name, 4, "[$name] ApacheStatus_Set: $opt=$value";
	
	if($opt eq 'refresh') {
	    ApacheStatus_FetchStatus($hash);
	    return undef;
	} elsif($opt eq 'reset') {
	    ApacheStatus_Reset($hash);
	    return undef;
	} elsif($opt eq 'disable') {
	    $hash->{STATE} = 'disabled';
	    $attr{$name}{disabled} = 'yes';
	    return undef;
	} elsif($opt eq 'enable') {
	    $attr{$name}{disabled} = 'no';
	    if(!defined($attr{$name}{autoReset}) || $attr{$name}{autoReset} ne 'yes') {
	        ApacheStatus_Reset($hash);
	    }
	    return undef;
	} elsif($opt eq 'allreadings') {
	    if($value =~ /^yes|no$/) {
	        $attr{$name}{readingsChilds}            = $value;
            $attr{$name}{readingsChildColumnDesc}   = $value;
            $attr{$name}{readingsClients}           = $value;
            $attr{$name}{readingsScoreboard}        = $value;
            $attr{$name}{readingsServer}            = $value;
            $attr{$name}{readingsSSL}               = $value;
            
            if(!defined($attr{$name}{autoReset}) || $attr{$name}{autoReset} ne 'yes') {
                ApacheStatus_Reset($hash);
            }
	        return undef;
        }
	} else {
        $hash->{STATE} = $ApacheStatus_sets{$opt} = $value;
        return "$opt set to $value";
    }
}

sub ApacheStatus_Attr(@) {
	my ($cmd,$name,$attr_name,$attr_value) = @_;
	if($cmd eq "set") {
        if($attr_name =~ /^(readings(Childs|ChildColumnDesc|Clients|SSL|Server|Scoreboard)|keepBuf|keepOldReadings|disabled|autoReset)$/) {
            if($attr_value !~ /^yes|no$/) {
			    my $err = "Invalid argument $attr_value to $attr_name. Must be yes or no.";
			    Log3 $name, 3, "[$name] ApacheStatus_Attr ERROR: $err";
			    return $err;
	        }
	        if(!defined($attr{$name}{autoReset}) || $attr{$name}{autoReset} ne 'yes') {
	            ApacheStatus_Reset($name);
	        }
        } elsif($attr_name =~ /^readingsChildsRowFilter|readingsChildsColumnFilter|localnetwork$/) {
			# todo: check regex
			if(!defined($attr{$name}{autoReset}) || $attr{$name}{autoReset} ne 'yes') {
			    ApacheStatus_Reset($name);
			}
		} elsif($attr_name =~ /^timeout|httpVersion|disabledForIntervals|verbose$/ || $readingFnAttributes =~ /$attr_name/) {
		    # attrs for HttpUtils / fhem.pl: do nothing
		} else {
		    # as long as not all possible global attributes are implemented above, this is a bad idea
		    # return "Unknown attr $attr_name";
		}
	}
	return undef;
}

sub ApacheStatus_Reset($) {
    my $hash = shift;
    if(ref $hash ne 'HASH' ) {
        $hash = $defs{$hash};
    }
    my $name = $hash->{NAME};
    
    foreach my $reading (keys %{$defs{$name}{READINGS}}) {
	    delete($defs{$name}{READINGS}{$reading});
	}
    Log3 $name, 4, "[$name] ApacheStatus_Reset";
    ApacheStatus_FetchStatus($hash);
}

sub ApacheStatus_FetchStatus($) {
    my $hash = shift;
    if(ref $hash ne 'HASH' ) {
        $hash = $defs{$hash};
    }
    my $name = $hash->{NAME};
    
    if(!IsDisabled($name) && (!defined($attr{$name}{disabled}) || $attr{$name}{disabled} ne 'yes')) {
        $hash->{STATE}           = 'fetching';
        $hash->{BUSY}            = 1;
        $hash->{LASTSEND}        = gettimeofday();
        $hash->{callback}        = \&ApacheStatus_Read;
        $hash->{timeout}         = AttrVal($name, "timeout", 2);
        $hash->{httpversion}     = AttrVal($name, "httpVersion", "1.0");
        $hash->{httpheader}      = undef;
        $hash->{buf}             = undef;
        $hash->{code}            = undef;
        $hash->{redirect}        = undef;

        Log3 $name, 4, "[$name] ApacheStatus_FetchStatus: starting HttpUtils_NonblockingGet";
        HttpUtils_NonblockingGet($hash);
    } else {
        Log3 $name, 4, "[$name] ApacheStatus_FetchStatus: Device is disabled";
        $hash->{STATE}           = 'disabled';
        ApacheStatus_SetTimer($hash);
    }
}

sub ApacheStatus_Read($$$) {
    my ($hash, $err, $body) = @_;

    my $now = gettimeofday();
    
    $hash->{BUSY} = 0;
    my $name = $hash->{NAME};
    
    if($err) {
        $hash->{STATE} = 'error';
        $hash->{error} = $err;
        Log3 $name, 3, "[$name] ApacheStatus_Read ERROR: $err";
    } else {
        $hash->{STATE} = 'parsing';
        delete($hash->{error}) if defined($hash->{error});

        my $tree = HTML::TreeBuilder::XPath->new;
        $tree->parse($body);
        my %r;
        
        $r{responsetime} = $now - $hash->{LASTSEND};

        my $noattrset=1;
        foreach my $a (keys %{$attr{$name}}) {
            if($a =~ /^readings/ && $attr{$name}{$a} eq 'yes') {
                $noattrset=0;
            }
        }
        if($noattrset) {
            $r{info} = 'no readings attribute set, please set at least one to "yes"';
            Log3 $name, 3, "[$name] ApacheStatus_Read: ".$r{info};
        }

        if(defined($attr{$name}{readingsServer}) && $attr{$name}{readingsServer} eq 'yes') {
            $r{server_status_title} = $tree->findvalue('//h1');
            
            foreach my $dt ($tree->findnodes('//dt')) {
                my $raw = $dt->findvalue('.');
                Log3 $name, 5, "[$name] ApacheStatus_Read: server-summary raw: $raw";
                        
                if( $raw =~ /(Total\saccesses):\s([0-9]+)\s-\s(Total\sTraffic):\s([0-9.]+\s[a-zA-Z]+)/) {
                    $r{'server_'.lc($1)} = $2 if $1&&$2;
                    $r{'server_'.lc($3)} = $4 if $3&&$4;
                    Log3 $name, 5, "[$name] ApacheStatus_Read: server-summary 1 ($1=$2, $3=$4)";
                } elsif( $raw =~ /([0-9.]+)\s(requests\/sec)\s-\s([0-9.]+)\s(kB\/second)\s-\s([0-9.]+)\s(kB\/request)/
                      || $raw =~ /([0-9]+)\s(requests\scurrently\sbeing\sprocessed),\s([0-9]+)\s(idle\sworkers)/ 
                ) {
                    $r{'server_requests_currently'} = $1 if $1&&$2;
                    $r{'server_'.lc($4)} = $3 if $3&&$4;
                    $r{'server_'.lc($6)} = $5 if $5&&$6;
                    Log3 $name, 5, "[$name] ApacheStatus_Read: server-summary 2 ($2=$1, $4=$3, $6=$5)";
                } elsif($raw =~ /:/) {
                    my @v = split(/:/, $raw);
                    my $reading = lc(shift @v);
                    $reading =~ s/\.//g; # avoid "config.-generation"
                    $reading =~ s/(parent\s)server\s/$1/g; # DBLOGs typical current.reading column is varchar(32) -> avoid longer reading names
                    $reading =~ s/^server\s//; # avoid server_server-...
                    my $value = join ':', @v;
                    $value =~ s/^\s+//;
                    $r{'server_'.$reading} = $value if $reading && $value;
                    Log3 $name, 5, "[$name] ApacheStatus_Read: server-summary 3 ($reading=$value)";
                }
            }
            
            if(defined($r{'server_load'}) && $r{'server_load'} =~ /([0-9.]+)\s+([0-9.]+)\s+([0-9.]+)/) {
                $r{'server_load-01'} = $1;
                $r{'server_load-05'} = $2;
                $r{'server_load-15'} = $3;
                Log3 $name, 5, "[$name] ApacheStatus_Read: server_load ($1, $2, $3)";
            }
            if(defined($r{'server_uptime'}) && $r{'server_uptime'} =~ /(?:([0-9]+)\s+days?\s+)?(?:([0-9]+)\shours?\s+)?(?:([0-9]+)\s+minutes?\s+)(?:([0-9]+)\s+seconds?)?/) {
                $r{'server_uptime-s'} = $1 * 60*60*24 + $2 * 60*60 + $3 * 60 + $4;
                Log3 $name, 5, "[$name] ApacheStatus_Read: server_uptime-s ($1, $2, $3 -> ".$r{'server_uptime-s'}.")";
            }
            if(defined($r{'server_cpu usage'}) && $r{'server_cpu usage'} =~ /u([0-9.]+)\s+s([0-9.]+)\s+cu([0-9]+)\s+cs([0-9]+)\s+-\s+([0-9.]+)%/) {
                $r{'server_cpu-usage-u'} = $1;
                $r{'server_cpu-usage-cu'} = $2;
                $r{'server_cpu-usage-cs'} = $3;
                $r{'server_cpu-usage-tu'} = $4;
                Log3 $name, 5, "[$name] ApacheStatus_Read: server_cpu-usage ($1, $2, $3, $4)";
            }
        }
        
        if(defined($attr{$name}{readingsScoreboard}) && $attr{$name}{readingsScoreboard} eq 'yes') {
            $r{scoreboard} = $tree->findvalue('//pre');
            $r{scoreboard_key} = $tree->findvalue('//p[starts-with(text(), "Scoreboard Key")]');
            Log3 $name, 5, "[$name] ApacheStatus_Read: server_scoreboard (".$r{scoreboard}.", ".$r{scoreboard_key}.")";
        }

        # readingsChilds
        my @tables = $tree->findnodes('//table');

        my @celltitle;
        my $n = 0;
        my %fieldno;
        foreach my $th ($tables[0]->findnodes('tr/th')) {
            my $cellvalue = $th->findvalue('.');
            # memorize position of columns
            $fieldno{$cellvalue} = $n;
            $fieldno{lc($cellvalue)} = $n;
            #
            $celltitle[$n]=$cellvalue;
            
            Log3 $name, 5, "[$name] ApacheStatus_Read: worker-table title $n=$cellvalue";
            
            $n++;
        }

        if(defined($attr{$name}{readingsClients}) && $attr{$name}{readingsClients} eq 'yes' && defined($attr{$name}{localnetwork})) {
            $r{clientrequests_localnetwork}=0;
            $r{clientrequests_externalnetwork}=0;
        }

        my $row = 0;
        foreach my $tr ($tables[0]->findnodes('tr[td]')) {
            my $reading = 'child'.$row.'_';
            my $n = 0;
            # read all td values into $r-entries
            foreach my $td ($tr->findnodes('td')) {
                my $cellvalue = $td->findvalue('.');
                if(defined($attr{$name}{readingsChilds}) && $attr{$name}{readingsChilds} eq 'yes') {
                    $r{$reading.$celltitle[$n]}=$cellvalue;
                    Log3 $name, 5, "[$name] ApacheStatus_Read: worker-table ".$reading.$celltitle[$n]."=$cellvalue";
                }
                if(defined($attr{$name}{readingsClients}) && $attr{$name}{readingsClients} eq 'yes') {
                    if($n==$fieldno{'client'}) {
                        if($cellvalue eq '::1') {
                            $cellvalue = 'localhost_ipv6';
                        } elsif($cellvalue eq '127.0.0.1') {
                            $cellvalue = 'localhost_ipv4';
                        }

                        my $req_reading = 'clientRequests_'.$cellvalue;
                        if(! defined($r{$req_reading})) {
                            $r{$req_reading}=1;
                        } else {
                            $r{$req_reading}++;
                        }
                        
                        if(defined($attr{$name}{localnetwork})) {
                            if($cellvalue =~ /$attr{$name}{localnetwork}|localhost_ipv[46]/) {
                                $r{clientrequests_localnetwork}++;
                            } else {
                                $r{clientrequests_externalnetwork}++;
                            }
                        }
                    }
                }
                $n++;
            }
                        
            if(defined($attr{$name}{readingsChilds}) && $attr{$name}{readingsChilds} eq 'yes') {
                # check if values are to be filtered by attr readingsChildsRowFilter
                if(defined($attr{$name}{readingsChildsRowFilter})) {
                    my $deleted = 0;
                    my @filter = split(/ +/, $attr{$name}{readingsChildsRowFilter});
                    foreach my $filter (@filter) {
                        if(!$deleted) {
                            my ($field,$regex) = split(/:/, $filter);
                            my $op = 'match';
                            # fieldnames starting with !
                            if($field =~ /^!/) {
                                $field =~ s/^!//;
                                $op = 'nomatch';
                            }
                            Log3 $name, 5, "[$name] ApacheStatus_Read: filtering readingsChildsRowFilter $filter (field $field, regex $regex)";
                            if( defined($r{$reading.$celltitle[$fieldno{$field}]})
                                && (   ($op eq 'match'   && $r{$reading.$celltitle[$fieldno{$field}]} !~ /$regex/) 
                                     ||($op eq 'nomatch' && $r{$reading.$celltitle[$fieldno{$field}]} =~ /$regex/) 
                                   )
                            ) {
                                # delete all $r-entries of the current row
                                Log3 $name, 5, "[$name] ApacheStatus_Read: readingsChildsRowFilter deleting $reading.*";
                                foreach my $celltitle (@celltitle) {
                                    if(defined($r{$reading.$celltitle})) {
                                        Log3 $name, 5, "[$name] ApacheStatus_Read: readingsChildsRowFilter deleting $reading$celltitle";
                                        # $r{$reading.$celltitle}=undef ;
                                        delete($r{$reading.$celltitle});
                                    }
                                }
                                $deleted = 1;
                            }
                        }
                    }
                }
                
                # check if values are to be filtered by attr colFilter
                if(defined($attr{$name}{readingsChildsColumnFilter})) {
                    my @filter = split(/ +/, $attr{$name}{readingsChildsColumnFilter});
                    foreach my $celltitle (@celltitle) {
                        my $keep = 0;
                        foreach my $filter (@filter) {
                            if($celltitle =~ /$filter/i) {
                                $keep = 1;
                            }
                        }
                        if(!$keep && defined($r{$reading.$celltitle})) {
                            Log3 $name, 5, "[$name] ApacheStatus_Read: readingsChildsColumnFilter deleting $reading$celltitle";
                            # $r{$reading.$celltitle}=undef ;
                            delete($r{$reading.$celltitle});
                        }
                    }
                }
	        }
            $row++;
        }
        
        if(defined($attr{$name}{readingsClients}) && $attr{$name}{readingsClients} eq 'yes') {
            $r{clientrequests_total} = $row;
        }
        
        if(defined($attr{$name}{readingsChildColumnDesc}) && $attr{$name}{readingsChildColumnDesc} eq 'yes') {
            foreach my $tr ($tables[1]->findnodes('tr')) {
                my $th = $tr->findvalue('th');
                my $td = $tr->findvalue('td');
                
                $r{'child_column_desc_'.$th} = $td;
            }
        }

        
        # readingsSSL
        if(defined($attr{$name}{readingsSSL}) && $attr{$name}{readingsSSL} eq 'yes') {
            my @ssltd = $tree->findnodes('//table[tr/td/b/font[starts-with(text(), "SSL/TLS Session Cache Status")]]/tr/td');
            my @raw = split(/total/, $ssltd[1]->findvalue('.'));
            my $raw = shift @raw;
            Log3 $name, 5, "[$name] ApacheStatus_Read: readingsSSL raw: $raw";
            if($raw =~ /(cache\stype):\s+(.*?),\s+(shared\smemory):\s+(.*?),\s+(current\sentries):\s(\d+)\s*/) {
                $r{'ssl_'.lc($1)} = $2 if $1&&$2;
                $r{'ssl_'.lc($3)} = $4 if $1&&$2;
                $r{'ssl_'.lc($5)} = $6 if $1&&$2;
            }
            if($raw =~ /(subcaches):\s+(\d+),\s+(indexes per subcache):\s+(\d+)/) {
                $r{'ssl_'.lc($1)} = $2 if $1&&$2;
                $r{'ssl_'.lc($3)} = $4 if $1&&$2;
            }
            if($raw =~ /(index usage):\s+(\d+)%,\s+(cache usage):\s+(\d+)%/) {
                $r{'ssl_'.lc($1)} = $2 if $1&&$2;
                $r{'ssl_'.lc($3)} = $4 if $1&&$2;
            }
            
            foreach my $total (@raw) {
                $total =~ s/^\s+//;
                Log3 $name, 5, "[$name] ApacheStatus_Read: readingsSSL total-line: $total";
                my ($reading, $value) = split(/: /, $total);
                # DBLOGs typical current.reading column is varchar(32) -> avoid longer reading names
                $reading =~ s/\ssince\sstarting//;
                $reading =~ s/\(pre-expiry\)\s//;
                $reading =~ s/\sof\sthe\scache//;
                $r{'ssl_total'.$reading} = $value;
            }
        }
                   
        my @oldreadings = keys %{$defs{$name}{READINGS}};
        
        # store readings
        readingsBeginUpdate($hash);
        if(keys %r) {
            foreach my $reading (keys(%r)) {
                my $value = $r{$reading};
                # $reading =~ s|/|_|g;
                $reading =~ s/[^a-z0-9_-]/-/ig;
                $reading =~ s/--+/-/g;
                readingsBulkUpdate($hash, $reading, $value);
                Log3 $name, 5, "[$name] ApacheStatus_Read: update reading $reading=$value";
            }
        }
        readingsEndUpdate($hash, 1);
        
        # cleanup
        if(!defined($attr{$name}{keepOldReadings}) || $attr{$name}{keepOldReadings} ne 'yes') {
            # delete old readings
            foreach my $oldreading (@oldreadings) {
	            my $still = 0;
	            foreach my $newreading (keys(%{$defs{$name}{READINGS}})) {
	                if($oldreading eq lc($newreading)) {
	                    $still = 1;
	                    last;
	                }
	            }
	            if(! $still) {
	                delete($defs{$name}{READINGS}{$oldreading});
	                Log3 $name, 5, "[$name] ApacheStatus_Read: cleanup reading $oldreading";
	            }
	        }
	    }
        
        if(defined($attr{$name}{keepBuf}) && $attr{$name}{keepBuf} ne 'yes') {
            delete($hash->{buf});
            Log3 $name, 5, "[$name] ApacheStatus_Read: cleanup buf";
        }
        $tree->delete();
        
        $hash->{STATE} = 'done';
    }
    
    Log3 $name, 4, "[$name] ApacheStatus_Read: done and call ApacheStatus_SetTimer";
    ApacheStatus_SetTimer($hash);
}

sub ApacheStatus_SetTimer($;$) {
    my ($hash, $start) = @_;
    my $nextTrigger;
    my $name = $hash->{NAME};
    my $now  = gettimeofday();
    $start   = 0 if (!$start);

    if($hash->{interval}) {
        if ($hash->{TimeAlign}) {
            my $count = int(($now - $hash->{TimeAlign} + $start) / $hash->{interval});
            my $curCycle = $hash->{TimeAlign} + $count * $hash->{interval};
            $nextTrigger = $curCycle + $hash->{interval};
        } else {
            $nextTrigger = $now + ($start ? $start : $hash->{interval});
        }
        
        $hash->{TRIGGERTIME}     = $nextTrigger;
        $hash->{TRIGGERTIME_FMT} = FmtDateTime($nextTrigger);
        RemoveInternalTimer("update:$name");
        Log3 $name, 4, "[$name] ApacheStatus_SetTimer: set InternalTimer";
        InternalTimer($nextTrigger, "ApacheStatus_FetchStatus", "$name", 0);
    } else {
       $hash->{TRIGGERTIME}     = 0;
       $hash->{TRIGGERTIME_FMT} = "";
    }
}

1;

=pod
=begin html

<a name="ApacheStatus"></a>
<h3>ApacheStatus</h3>
<ul>
    <i>ApacheStatus</i> queries a server-statuspage generated by 
    <a href="https://httpd.apache.org/docs/2.4/mod/mod_status.html">Apaches mod_status</a>
    and generates various readings from it. The query is repeated in a given interval. 
    <br><br>
    <b>Prerequisites</b>
    <ul>
        <li>HTML::TreeBuilder::XPath needs to be installed. (debian: <i>apt-get install libhtml-treebuilder-xpath-perl</i>)</li>
        <li>mod_status needs to be enabled in Apache</li>
        <li>server-status-page must be accessible for fhem (/etc/apache2/mods-enabled/status.conf may restrict access)</li>
    </ul>
    <br><br>
    <a name="ApacheStatusdefine"></a>
    <b>Define</b>
    <ul>
        <code>define &lt;name&gt; ApacheStatus &lt;URL&gt; [&lt;INTERVAL&gt;]</code>
        <br><br>
        Example: <code>define APACHESTATUS ApacheStatus http://localhost/server-status 300</code>
        <br><br>
        <b>URL</b> is the url of a server-statuspage generated by mod_status. User and password for HTTP basic authentication may be provided in standard notation: http://user:pass@host<br>
        <b>INTERVAL</b> is the refresh interval in seconds. Default: 300
        <br><br>
        Since <i>ApacheStatus</i> is designed to create very differentiated readings from  
        the info mod_status provides, it can easily make for hundreds of readings. To avoid 
        that, you'll have to explicitly enable groups of readings by setting associated 
        attributes. For details see below.<br>
        A newly created device has some attributes set to default values:
        <ul>
            <li><i>autoReset</i>: yes</li>
            <li><i>disabled</i>: no</li>
            <li><i>event-on-change-reading</i>: .*</li>
            <li><i>keepBuf</i>: no</li>
            <li><i>keepOldReadings</i>: no</li>
            <li><i>readingsChilds</i>: no</li>
            <li><i>readingsChildColumnDesc</i>: no</li>
            <li><i>readingsChildsRowFilter</i>: !request:^OPTIONS !request:^NULL</li>
            <li><i>readingsChildsColumnFilter</i>: req conn child client request</li>
            <li><i>readingsClients</i>: no</li>
            <li><i>readingsScoreboard</i>: no</li>
            <li><i>readingsServer</i>: no</li>
            <li><i>readingsSSL</i>: no</li>
        </ul>
        <b>Caution:</b> If your editing fhem.cfg to add a new device none of these attributes are set automatically
    </ul>
    <br>
    
    <a name="ApacheStatusset"></a>
    <b>Set</b><br>
    <ul>
        <ul>
            <li><i>allreadings yes|no</i><br>
                Sets all readings-attributes to "yes" or "no"</li>
            <li><i>disable</i><br>
                Disables automatic refresh (enabled by default)</li>
            <li><i>enable</i><br>
                Enables automatic refresh</li>
            <li><i>reset</i><br>
                Deletes all readings and rereads them</li>
            <li><i>refresh</i><br>
                Immediately refreshes all readings</li>
        </ul>
    </ul>
    <br>

    <a name="ApacheStatusattr"></a>
    <b>Attributes</b>
    <ul>
        <ul>
            <li><i>autoReset</i> yes|no<br>
                Since most attributes do effect the creation of readings, the module automatically resets all readings when changing attributes. Set to "no" to disable this behaviour. May be usefull if you want to keep outdated readings (see keepOldReadings bellow). Default: yes</li>
            <li><i>disabled</i> yes|no<br>
                Disables automatic refresh. disabledForIntervals has higher precedence then disabled=no. Default: no</li>
            <li><a href='#disabledForIntervals'>disabledForIntervals</a></li>
            <li><i>httpVersion</i> #<br>
                HTTP-Version to send to the server. Inherited from HttpUtils. Default: 1.0</li>
            <li><i>keepBuf</i> yes|no<br>
                Keep server-status-HTML in the internal value 'buf'? Default: no</li>
            <li><i>keepOldReadings</i> yes|no<br>
                Keep readings which aren't present in the last fetch of server-status? Caution: <i>set DEVICE reset</i> deletes all readings regardless of <i>keepOldReadings</i>. Default: no</li>
            <li><i>localnetwork</i> &lt;regex&gt;<br>
                Regular expression that matches all adresses in your local network. It is used 
                to distinguish local clients from external clients when counting client requests. 
                localhost-adresses (127.0.0.1, ::1) are always counted to the local network 
                automatically<br>
                <br>
                Example: <i>192.168.178</i></li>
            <li><i>readingsChildColumnDesc</i> yes|no<br>
                The server-status page contains a description of all columns of the table with 
                child-information (see below). If set to yes, these descriptions are transfered 
                as readings. Default: no</li>
            <li><i>readingsChilds</i> yes|no<br>
                Create readings of the table with child-information ("Srv PID Acc.."). For each row and 
                each colum a single reading is created. Caution: This can easily make for hundrets of 
                readings, avoid usage without readingsChildsRowFilter/readingsChildsColumnFilter. 
                Default: no</li>
            <li><i>readingsChildsRowFilter</i> &lt;column:regex&gt; &lt;column:regex&gt; ...<br>
                Only include rows of readings of child-information, when at least one condition in
                the space separated list of colum:regex-pairs is met. <br>
                <ul>
                    <li><i>column</i> is the title of a column of that table (e.g. "srv", "pid", "acc") and may be preceeded with an ! to negate the following regex. </li>
                    <li><i>regex</i> is a regular expression describing the value of a cell</li>
                </ul>
                <br>
                Example: <i>request:^GET !client:^127.0.0.1$</i><br>
                <ul>
                    creates readings only if the request-cell starts whith "GET" and the client-cell is not "127.0.0.1"
                </ul></li>
            <li><i>readingsChildsColumnsFilter</i> &lt;column&gt; &lt;column&gt; ...<br>
                If the attribute is set, readings are included only for columns that are listed here. Otherwise all columns are included.<br>
                <br>
                Example: <i>client request</i><br>
                <ul>
                    creates readings only for columns <i>client</i> and <i>request</i>
                </ul></li>
            <li><i>readingsClients</i> yes|no<br>
                Create readings for the count of requests per client? Default: no</li>
            <li><i>readingsSSL</i> yes|no<br>
                Create readings from the SSL/TLS session cache status-table? This table is not always included in server-status. Default: no</li>
            <li><i>readingsServer</i> yes|no<br>
                Create readings from server information (top of status-page)? Default: no</li>
            <li><i>readingsScoreboard</i> yes|no<br>
                Create readings from the scoreboard? Default: no</li>
            <li><i>timeout</i> #<br>
                Timeout to wait for servers response. Inherited from HttpUtils. Default: 2</li>
            <li><a href='#readingFnAttributes'>readingFnAttributes</a></li>
        </ul>
    </ul>
    
    <a name="ApacheStatusSTATE"></a>
    <b>Values of STATE</b>
    <ul>
        <ul>
            <li><i>defined</i><br>
                device is defined</li>
            <li><i>fetching</i><br>
                device is fetching it's URL</li>
            <li><i>parsing</i><br>
                device is parsing HTML (response from fetching URL)</li>
            <li><i>done</i><br>
                device is done parsing and waiting for the next run</li>
            <li><i>disabled</i><br>
                device is disabled</li>
            <li><i>error</i><br>
                an error occured</li>
        </ul>
    </ul>
</ul>

=end html

=cut
